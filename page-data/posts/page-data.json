{
    "componentChunkName": "component---src-templates-category-template-js",
    "path": "/posts",
    "result": {"pageContext":{"currentCategory":"All","edges":[{"node":{"id":"2ca0b99e-825f-5cc2-afde-4a39062d2351","excerpt":"공부 방법 혼자 취준을 시작하면서 알고리즘부터 다시 시작하기로 했다. 초심자의 마음가짐으로 노션에 정리하면서 풀기 시작한지 일주일 정도 되었다. 뭔가 정체된 느낌이 들던 찰나 류호석님 실시간을 보고 공부 방법을 조정하기로 했다.\n아래는 유튜브 내용을 내가 다시 보기 위해 정리한 것이다. A. 정확히 이해하고 넘어가자. Option 1) 짝을 이뤄서 서로에게 설명하기 문제에 어떻게 접근했는지, 어떻게 풀었는지 상세하게 설명하고 피드백 받는 방식이다. 난 스터디 메이트가 없으니 패쓰 Option 2) 주석을 정말 완전 최고로 열심히 달기 주석을 문장 형태로 작성한다. 변수들의 의미 함수들의 입출력, 시간복잡도 실상 Op1을 글로 풀어쓰는 것과 같은 느낌. 이렇게 하면 나중에 다시 봐도 이해하기 쉽고 완전히 풀어낸 느낌이 들 것 같다. B. 시간을 정해 놓고 풀자. 난이도에 맞는 유동적인 시간 설정 삼성 기출 : 2시간 ~Silver : 1시간 ~Gold : 2시간 시간을 정해두고 온전…","fields":{"slug":"/algorithm-study-guideline/"},"frontmatter":{"categories":"알고리즘","title":"혼자 코딩테스트 준비하기","date":"December 19, 2022"}},"next":{"fields":{"slug":"/boj-9252/"}},"previous":null},{"node":{"id":"d0153900-88aa-59d6-9cc7-9e68e5db5bdf","excerpt":"❔ 문제 문제 바로가기 유형 : DP 역추적 티어 : Gold4 ❕ 풀이 9251 LCS 문제와 동일하게 공통 부분 수열의 최대 길이를 출력하고 그 문자열까지 출력하는 문제이다.\n즉, 경로를 역추적해서 답을 찾는다. → 경로를 저장하는 2차원 배열이 추가로 필요하다. 어느 방향에서 왔는지 저장한다. (0: 위에서, 1: 왼쪽에서, 2: 좌상향에서) 👀 코드 👣 결과 소요 시간 : 1 h\n ❔ 문제 문제 바로가기 유형 : DP 역추적 티어 : Gold4 ❕ 풀이 👀 코드 👣 결과","fields":{"slug":"/boj-9252/"},"frontmatter":{"categories":"알고리즘","title":"〈백준〉 9252번 LCS 2","date":"December 14, 2022"}},"next":{"fields":{"slug":"/boj-9251/"}},"previous":{"fields":{"slug":"/algorithm-study-guideline/"}}},{"node":{"id":"2fba5012-cd1c-5493-893f-ad1fbdb0eb17","excerpt":"❔ 문제 문제 바로가기 유형 : DP 역추적 티어 : Gold5 ❕ 풀이 동적 계획법 포스트 작성하면서 푼 문제 2차원 테이블을 생성해서 가능한 문자열들의 조합에 대한 공통 부분 수열의 최대 길이를 저장한다. 두 문자가 서로 다른 곳은 공통 부분 문자열에 속하지 않으므로 그 전의 길이 최댓값 그대로 가져옴 → 위쪽 or 왼쪽 두 문자가 서로 같은 곳은 공통 부분 문자열에 추가되므로 해당 문자들이 포함되기 전의 길이 + 1 → 좌상향 대각선 👀 코드 👣 결과 소요 시간 : 30 m\n ❔ 문제 문제 바로가기 유형 : DP 역추적 티어 : Gold5 ❕ 풀이 👀 코드 👣 결과","fields":{"slug":"/boj-9251/"},"frontmatter":{"categories":"알고리즘","title":"〈백준〉 9251번 LCS","date":"December 14, 2022"}},"next":{"fields":{"slug":"/boj-14002/"}},"previous":{"fields":{"slug":"/boj-9252/"}}},{"node":{"id":"3b14d8d8-42e1-53af-aeff-ab593f13b4cb","excerpt":"❔ 문제 문제 바로가기 유형 : DP 역추적 티어 : Gold4 ❕ 풀이 11053 가장 긴 증가하는 부분 수열 문제와 동일하게 LIS의 길이를 출력하고 수열을 출력하는 문제이다.\n즉, 경로를 역추적해서 답을 찾는다. → 경로를 저장하는 배열이 추가로 필요하다. answer 변수 초기값 설정에 주의해야한다. (인덱스는 0으로, 길이는 1으로, 왜냐면 감소하는 배열일 수도 있기 때문에!) 👀 코드 👣 결과 소요 시간 : 1 h\n ❔ 문제 문제 바로가기 유형 : DP 역추적 티어 : Gold4 ❕ 풀이 👀 코드 👣 결과","fields":{"slug":"/boj-14002/"},"frontmatter":{"categories":"알고리즘","title":"〈백준〉 14002번 가장 긴 증가하는 부분 수열 4","date":"December 14, 2022"}},"next":{"fields":{"slug":"/boj-11053/"}},"previous":{"fields":{"slug":"/boj-9251/"}}},{"node":{"id":"fd53d7c4-d1a0-509d-a06d-7b423e541e0a","excerpt":"❔ 문제 문제 바로가기 유형 : DP 티어 : Silver2 ❕ 풀이 동적 계획법 포스트 작성하면서 푼 문제\n0번 인덱스부터 탐색하며 해당 인덱스로 끝나는 부분 수열의 최댓값을 계산하는 방식으로 풀었다. 👀 코드 👣 결과 소요 시간 : 30 m\n ❔ 문제 문제 바로가기 유형 : DP 티어 : Silver2 ❕ 풀이 👀 코드 👣 결과","fields":{"slug":"/boj-11053/"},"frontmatter":{"categories":"알고리즘","title":"〈백준〉 11053번 가장 긴 증가하는 부분 수열","date":"December 14, 2022"}},"next":{"fields":{"slug":"/dynamic-programming/"}},"previous":{"fields":{"slug":"/boj-14002/"}}},{"node":{"id":"d5c9f798-fb6f-52e5-8bcd-7718037c5480","excerpt":"동적 계획법이란? 동적 계획법 특정 범위까지의 값을 구하기 위해 이전 범위의 값을 활용하여 효율적으로 값을 얻는 기법 이전 범위의 값을 저장(Memoization)함으로써 시간적, 공간적 효율 얻음 피보나치 수 10870 피보나치 수 5 문제 F(n) = F(n - 1) + F(n - 2) (n >= 2) n번째 피보나치 수를 구하는 문제 제한사항 0 <= n <= 20 재귀함수로 풀 수 있다! 15624 피보나치 수 7 문제 F(n) = F(n - 1) + F(n - 2) (n >= 2) n번째 피보나치 수를 구하는 문제 제한사항 0 <= n <= 1,000,000 재귀함수로? 절대 불가능하다! n의 범위가 커서 시간초과가 난다 n = 4  함수 호출 수 f(4) : 1 f(3) : 1 f(2) : 2 f(1) : 3 f(0) : 2 → 같은 함수를 여러 번 호출하는 경우가 많다! n = 20이라면? 함수 호출 수 f(0) : 4181 f(1) : 6765 f(2) : 4181 …","fields":{"slug":"/dynamic-programming/"},"frontmatter":{"categories":"알고리즘","title":"〈알고리즘〉 동적 계획법","date":"December 14, 2022"}},"next":{"fields":{"slug":"/boj-13913/"}},"previous":{"fields":{"slug":"/boj-11053/"}}},{"node":{"id":"2792b427-1b39-505e-813d-0c7eabdce847","excerpt":"❔ 문제 문제 바로가기 유형: BFS 역추적 티어 : Gold4 ❕ 풀이 역추적을 활용하는 BFS 문제 PQ와 visited 배열을 활용해서 최단거리를 찾고 path 배열에 이동 이전의 인덱스를 저장하였다. 그래서 동생 위치에서부터 수빈이까지 도달하는 경로를 거꾸로 출력해주면 풀리는 문제였다. 시간을 더 어떻게 줄여야할지는 모르겠다… (insert가 오래 걸리는 것 같기도 하고?) 👀 코드 👣 결과 소요 시간 : 1 h\n ❔ 문제 문제 바로가기 유형: BFS 역추적 티어 : Gold4 ❕ 풀이 👀 코드 👣 결과","fields":{"slug":"/boj-13913/"},"frontmatter":{"categories":"알고리즘","title":"〈백준〉 13913번 숨바꼭질 4","date":"December 13, 2022"}},"next":{"fields":{"slug":"/boj-13549/"}},"previous":{"fields":{"slug":"/dynamic-programming/"}}},{"node":{"id":"295a09f7-f8c3-5d6a-9e63-f95e16a463e7","excerpt":"❔ 문제 문제 바로가기 유형 : 다익스트라 티어 : Gold5 ❕ 풀이 중요한 문제 조건 : 순간이동을 하는 경우에는 0초 후에 2*X의 위치로 이동하게 된다. 처음에 BFS로만 풀어보려고 했다. → 결과 : 틀렸습니다. 이유 : BFS는 모든 간선의 가중치가 동일해야 한다는 전제 조건이 필요하다. 그래서 질문 게시판과 유형을 참고해보니 풀이 방식을 3가지 정도로 나눌 수 있다고 한다. 다익스트라 알고리즘 0-1 BFS: 가중치가 0인 간선에 연결된 정점은 큐의 맨 뒤가 아닌 맨 앞에 넣는 방법 2를 별도의 간선으로 생각하지 않고, +1이나 -1에 의한 좌표를 큐에 넣을 때 그 좌표의 2의 거듭제곱 배인 좌표들을 전부 큐에 넣는 방법 이 중 다익스트라 알고리즘(+ 우선순위 큐) 활용해서 풀었다. 나중에 0-1 BFS에 대해서도 공부해보면서 다시 풀면 좋을 것 같다. 👀 코드 👣 결과 소요 시간 : 1 h\n ❔ 문제 문제 바로가기 유형 : 다익스트라 티어 : Gold5 ❕ 풀이 👀 …","fields":{"slug":"/boj-13549/"},"frontmatter":{"categories":"알고리즘","title":"〈백준〉 13549번 숨바꼭질 3","date":"December 13, 2022"}},"next":{"fields":{"slug":"/boj-14888/"}},"previous":{"fields":{"slug":"/boj-13913/"}}},{"node":{"id":"bbd4468a-aa07-5c1d-bd4d-0b1695afb672","excerpt":"❔ 문제 문제 바로가기 유형 : 브루트포스 백트래킹 티어 : Silver1 ❕ 풀이 브루트포스 + 백트래킹 DFS로 모든 경우의 수를 다 해본다. 순열 생각하면서 연산자 개수가 남아있으면 계산하고 재귀 호출했다. 종료 조건은 마지막 피연산자까지 계산했을 때, 그리고 min, max 각각 확인했다. 연산자 개수를 딱 맞게 제공해서 예외 처리(out of bound)가 필요없었다. 굳. 👀 코드 👣 결과  소요 시간 : 30 m 후기 :\n풀면 안 어려운데 순열, 조합 이런 거 다시 기억해볼라니까 좀 막막했다.\n예외 생기지 않게 연산자 개수 딱 맞게 줬는데 그렇지 않은 가정으로 풀어도 좋을 듯? (연산자가 전부 0개이면 재귀 호출하지 않게 짰음) ❔ 문제 문제 바로가기 유형 : 브루트포스 백트래킹 티어 : Silver1 ❕ 풀이 👀 코드 👣 결과","fields":{"slug":"/boj-14888/"},"frontmatter":{"categories":"알고리즘","title":"〈백준〉 14888번 연산자 끼워넣기","date":"December 12, 2022"}},"next":{"fields":{"slug":"/boj-3055/"}},"previous":{"fields":{"slug":"/boj-13549/"}}},{"node":{"id":"afc54183-1a0e-5284-bb6e-8269e7ac7027","excerpt":"❔ 문제 문제 바로가기 유형 : BFS 티어 : Gold3 ❕ 풀이 심플한 BFS 활용 문제 : 늘 그렇듯 check 배열을 int로 만들어서 이동시간과 중복 확인을 동시에 함 한 단위 시간마다 물 확장 (’고슴도치는 물이 찰 예정인 칸으로 이동할 수 없다’ → 물을 먼저 확장한다) 물은 빈 칸으로만 확장 가능 고슴도치 이동 비버의 소굴이나 빈 칸으로 이동 가능 내가 생각하기에 중요한 포인트는 단위 시간마다 queue의 크기만큼만 돌아야한다는 점 물도, 고슴도치도! 👀 코드 👣 결과 소요 시간 : 30 m\n ❔ 문제 문제 바로가기 유형 : BFS 티어 : Gold3 ❕ 풀이 👀 코드 👣 결과","fields":{"slug":"/boj-3055/"},"frontmatter":{"categories":"알고리즘","title":"〈백준〉 3055번 탈출","date":"December 12, 2022"}},"next":null,"previous":{"fields":{"slug":"/boj-14888/"}}}],"categories":["All","알고리즘"]}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}