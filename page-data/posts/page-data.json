{
    "componentChunkName": "component---src-templates-category-template-js",
    "path": "/posts",
    "result": {"pageContext":{"currentCategory":"All","edges":[{"node":{"id":"2ca0b99e-825f-5cc2-afde-4a39062d2351","excerpt":"공부 방법 혼자 취준을 시작하면서 알고리즘부터 다시 시작하기로 했다. 초심자의 마음가짐으로 노션에 정리하면서 풀기 시작한지 일주일 정도 되었다. 뭔가 정체된 느낌이 들던 찰나 류호석님 실시간을 보고 공부 방법을 조정하기로 했다.\n아래는 유튜브 내용을 내가 다시 보기 위해 정리한 것이다. A. 정확히 이해하고 넘어가자. Option 1) 짝을 이뤄서 서로에게 설명하기 문제에 어떻게 접근했는지, 어떻게 풀었는지 상세하게 설명하고 피드백 받는 방식이다. 난 스터디 메이트가 없으니 패쓰 Option 2) 주석을 정말 완전 최고로 열심히 달기 주석을 문장 형태로 작성한다. 변수들의 의미 함수들의 입출력, 시간복잡도 실상 Op1을 글로 풀어쓰는 것과 같은 느낌. 이렇게 하면 나중에 다시 봐도 이해하기 쉽고 완전히 풀어낸 느낌이 들 것 같다. B. 시간을 정해 놓고 풀자. 난이도에 맞는 유동적인 시간 설정 삼성 기출 : 2시간 ~Silver : 1시간 ~Gold : 2시간 시간을 정해두고 온전…","fields":{"slug":"/algorithm-study-guideline/"},"frontmatter":{"categories":"알고리즘","title":"혼자 코딩테스트 준비하기","date":"December 19, 2022"}},"next":{"fields":{"slug":"/boj-14002/"}},"previous":null},{"node":{"id":"3b14d8d8-42e1-53af-aeff-ab593f13b4cb","excerpt":"❔ 문제 문제 바로가기 ❕ 풀이 LIS 문제, DP + 역추적으로 풀었다. dp 배열은 해당 수를 마지막 원소를 가지는 최장 길이를 저장하고 path 배열은 이전 경로를 저장한다. answer 변수 초기값 설정에 주의해야한다. (인덱스는 0으로, 길이는 1으로, 왜냐면 감소하는 배열일 수도 있기 때문에!) 👀 코드 👣 결과 소요 시간 : 1 h\n ❔ 문제 문제 바로가기 ❕ 풀이 👀 코드 👣 결과","fields":{"slug":"/boj-14002/"},"frontmatter":{"categories":"알고리즘","title":"BOJ 14002 가장 긴 증가하는 부분 수열 4","date":"December 14, 2022"}},"next":{"fields":{"slug":"/boj-13913/"}},"previous":{"fields":{"slug":"/algorithm-study-guideline/"}}},{"node":{"id":"2792b427-1b39-505e-813d-0c7eabdce847","excerpt":"❔ 문제 문제 바로가기 ❕ 풀이 역추적을 활용하는 BFS 문제 PQ와 visited 배열을 활용해서 최단거리를 찾고 path 배열에 이동 이전의 인덱스를 저장하였다. 그래서 동생 위치에서부터 수빈이까지 도달하는 경로를 거꾸로 출력해주면 풀리는 문제였다. 시간을 더 어떻게 줄여야할지는 모르겠다… (insert가 오래 걸리는 것 같기도 하고?) 👀 코드 👣 결과 소요 시간 : 1 h\n ❔ 문제 문제 바로가기 ❕ 풀이 👀 코드 👣 결과","fields":{"slug":"/boj-13913/"},"frontmatter":{"categories":"알고리즘","title":"BOJ 13913 숨바꼭질 4","date":"December 13, 2022"}},"next":{"fields":{"slug":"/boj-13549/"}},"previous":{"fields":{"slug":"/boj-14002/"}}},{"node":{"id":"295a09f7-f8c3-5d6a-9e63-f95e16a463e7","excerpt":"❔ 문제 문제 바로가기 ❕ 풀이 중요한 문제 조건 : 순간이동을 하는 경우에는 0초 후에 2*X의 위치로 이동하게 된다. 처음에 BFS로만 풀어보려고 했다. → 결과 : 틀렸습니다. 이유 : BFS는 모든 간선의 가중치가 동일해야 한다는 전제 조건이 필요하다. 그래서 질문 게시판과 유형을 참고해보니 풀이 방식을 3가지 정도로 나눌 수 있다고 한다. 다익스트라 알고리즘 0-1 BFS: 가중치가 0인 간선에 연결된 정점은 큐의 맨 뒤가 아닌 맨 앞에 넣는 방법 2를 별도의 간선으로 생각하지 않고, +1이나 -1에 의한 좌표를 큐에 넣을 때 그 좌표의 2의 거듭제곱 배인 좌표들을 전부 큐에 넣는 방법 이 중 다익스트라 알고리즘(+ 우선순위 큐) 활용해서 풀었다. 나중에 0-1 BFS에 대해서도 공부해보면서 다시 풀면 좋을 것 같다. 👀 코드 👣 결과 소요 시간 : 1 h\n ❔ 문제 문제 바로가기 ❕ 풀이 👀 코드 👣 결과","fields":{"slug":"/boj-13549/"},"frontmatter":{"categories":"알고리즘","title":"BOJ 13549 숨바꼭질 3","date":"December 13, 2022"}},"next":{"fields":{"slug":"/boj-14888/"}},"previous":{"fields":{"slug":"/boj-13913/"}}},{"node":{"id":"bbd4468a-aa07-5c1d-bd4d-0b1695afb672","excerpt":"❔ 문제 문제 바로가기 ❕ 풀이 브루트포스 + 백트래킹 DFS로 모든 경우의 수를 다 해본다. 순열 생각하면서 연산자 개수가 남아있으면 계산하고 재귀 호출했다. 종료 조건은 마지막 피연산자까지 계산했을 때, 그리고 min, max 각각 확인했다. 연산자 개수를 딱 맞게 제공해서 예외 처리(out of bound)가 필요없었다. 굳. 👀 코드 👣 결과  소요 시간 : 30 m 후기 :\n풀면 안 어려운데 순열, 조합 이런 거 다시 기억해볼라니까 좀 막막했다.\n예외 생기지 않게 연산자 개수 딱 맞게 줬는데 그렇지 않은 가정으로 풀어도 좋을 듯? (연산자가 전부 0개이면 재귀 호출하지 않게 짰음) ❔ 문제 문제 바로가기 ❕ 풀이 👀 코드 👣 결과","fields":{"slug":"/boj-14888/"},"frontmatter":{"categories":"알고리즘","title":"BOJ 14888 연산자 끼워넣기","date":"December 12, 2022"}},"next":{"fields":{"slug":"/boj-3055/"}},"previous":{"fields":{"slug":"/boj-13549/"}}},{"node":{"id":"afc54183-1a0e-5284-bb6e-8269e7ac7027","excerpt":"❔ 문제 문제 바로가기 ❕ 풀이 심플한 BFS 활용 문제 : 늘 그렇듯 check 배열을 int로 만들어서 이동시간과 중복 확인을 동시에 함 한 단위 시간마다 물 확장 (’고슴도치는 물이 찰 예정인 칸으로 이동할 수 없다’ → 물을 먼저 확장한다) 물은 빈 칸으로만 확장 가능 고슴도치 이동 비버의 소굴이나 빈 칸으로 이동 가능 내가 생각하기에 중요한 포인트는 단위 시간마다 queue의 크기만큼만 돌아야한다는 점 물도, 고슴도치도! 👀 코드 👣 결과 소요 시간 : 30 m\n ❔ 문제 문제 바로가기 ❕ 풀이 👀 코드 👣 결과","fields":{"slug":"/boj-3055/"},"frontmatter":{"categories":"알고리즘","title":"BOJ 3055 탈출","date":"December 12, 2022"}},"next":null,"previous":{"fields":{"slug":"/boj-14888/"}}}],"categories":["All","알고리즘"]}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}